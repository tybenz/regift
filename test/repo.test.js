// Generated by CoffeeScript 1.7.1
(function() {
  var Actor, Commit, Diff, Head, Ref, Status, Tag, Tree, exec, fixtures, fs, git, should, sinon, _ref;

  should = require('should');

  sinon = require('sinon');

  fs = require('fs-extra');

  fixtures = require('./fixtures');

  git = require('../src');

  Actor = require('../src/actor');

  Commit = require('../src/commit');

  Tree = require('../src/tree');

  Diff = require('../src/diff');

  Tag = require('../src/tag');

  Status = require('../src/status');

  _ref = require('../src/ref'), Ref = _ref.Ref, Head = _ref.Head;

  exec = require('child_process').exec;

  describe("Repo", function() {
    describe("#add", function() {
      var file, git_dir, repo, status;
      repo = null;
      git_dir = __dirname + "/fixtures/junk_add";
      status = null;
      file = null;
      before(function(done) {
        return fs.remove(git_dir, function(err) {
          if (err) {
            return done(err);
          }
          return fs.mkdir(git_dir, '0755', function(err) {
            if (err) {
              return done(err);
            }
            return git.init(git_dir, function(err) {
              if (err) {
                return done(err);
              }
              repo = git(git_dir);
              return done();
            });
          });
        });
      });
      after(function(done) {
        return fs.remove(git_dir, done);
      });
      describe("with only a file", function() {
        file = 'foo.txt';
        before(function(done) {
          return fs.writeFile("" + git_dir + "/" + file, "cheese", function(err) {
            if (err != null) {
              return done(err);
            }
            return repo.add("" + git_dir + "/" + file, function(err) {
              if (err != null) {
                return done(err);
              }
              return repo.status(function(err, _status) {
                status = _status;
                return done(err);
              });
            });
          });
        });
        return it("was added", function() {
          status.files.should.have.a.property(file);
          status.files[file].staged.should.be["true"];
          status.files[file].tracked.should.be["true"];
          return status.files[file].type.should.eql('A');
        });
      });
      return describe("with no file and all option", function() {
        file = 'bar.txt';
        before(function(done) {
          return fs.writeFile("" + git_dir + "/" + file, "cheese", function(err) {
            if (err != null) {
              return done(err);
            }
            return repo.add([], {
              A: true
            }, function(err) {
              if (err != null) {
                return done(err);
              }
              return repo.status(function(err, _status) {
                status = _status;
                return done(err);
              });
            });
          });
        });
        return it("was added", function() {
          status.files.should.have.a.property(file);
          status.files[file].staged.should.be["true"];
          status.files[file].tracked.should.be["true"];
          return status.files[file].type.should.eql('A');
        });
      });
    });
    describe("#sync", function() {
      return describe("when passed curried arguments", function() {
        var branch, remote, repo;
        repo = fixtures.branched;
        remote = branch = "";
        before(function() {
          sinon.stub(repo, "git", function(command, opts, args, callback) {
            if (command === "pull") {
              remote = args[0];
              branch = args[1];
            }
            return typeof callback === "function" ? callback(null) : void 0;
          });
          return sinon.stub(repo, "status", function(callback) {
            return typeof callback === "function" ? callback(null, {
              clean: false
            }) : void 0;
          });
        });
        after(function() {
          repo.git.restore();
          return repo.status.restore();
        });
        it("passes through the correct parameters when nothing is omitted", function(done) {
          return repo.sync("github", "my-branch", function() {
            remote.should.eql("github");
            branch.should.eql("my-branch");
            return done();
          });
        });
        it("passes through the correct parameters when remote_name is omitted", function(done) {
          return repo.sync("my-branch", function() {
            remote.should.eql("origin");
            branch.should.eql("my-branch");
            return done();
          });
        });
        return it("passes through the correct parameters when remote_name and branch are omitted", function(done) {
          return repo.sync(function() {
            remote.should.eql("origin");
            branch.should.eql("master");
            return done();
          });
        });
      });
    });
    describe("#identify", function() {
      return describe("when asked to set the identity's name and email", function() {
        var email, id, ident, name, repo;
        repo = fixtures.branched;
        id = '' + new Date().getTime();
        name = "name-" + id;
        email = "" + id + "@domain";
        ident = null;
        before(function(done) {
          var actor;
          actor = new Actor(name, email);
          return repo.identify(actor, function(err) {
            if (err) {
              done(err);
            }
            return repo.identity(function(err, _actor) {
              ident = _actor;
              return done(err);
            });
          });
        });
        after(function(done) {
          return exec("git checkout -- " + repo.path, done);
        });
        return it("has correctly set them", function() {
          ident.name.should.eql(name);
          return ident.email.should.eql(email);
        });
      });
    });
    describe("#commits", function() {
      describe("with a single commit", function() {
        var commit, git_dir, repo;
        repo = null;
        commit = null;
        git_dir = __dirname + "/fixtures/junk_commit";
        before(function(done) {
          return fs.remove(git_dir, function(err) {
            if (err != null) {
              return done(err);
            }
            return fs.mkdir(git_dir, '0755', function(err) {
              if (err != null) {
                return done(err);
              }
              return git.init(git_dir, function(err) {
                if (err != null) {
                  return done(err);
                }
                repo = git(git_dir);
                fs.writeFileSync("" + git_dir + "/foo.txt", "cheese");
                return repo.identify(new Actor('root', 'root@domain.net'), function(err) {
                  if (err != null) {
                    return done(err);
                  }
                  return repo.add("" + git_dir + "/foo.txt", function(err) {
                    if (err != null) {
                      return done(err);
                    }
                    return repo.commit('message with spaces', {
                      author: 'Someone <someone@somewhere.com>'
                    }, function(err) {
                      if (err != null) {
                        return done(err);
                      }
                      return repo.commits(function(err, _commits) {
                        commit = _commits[0];
                        return done(err);
                      });
                    });
                  });
                });
              });
            });
          });
        });
        after(function(done) {
          return fs.remove(git_dir, done);
        });
        it("has right message", function(done) {
          commit.message.should.eql('message with spaces');
          commit.author.name.should.eql('Someone');
          commit.author.email.should.eql('someone@somewhere.com');
          return done();
        });
        return it("has a tree", function(done) {
          commit.tree().should.be.an["instanceof"](Tree);
          return commit.tree().contents(function(err, child) {
            if (err) {
              return done(err);
            }
            child.length.should.eql(1);
            child[0].name.should.eql('foo.txt');
            return done();
          });
        });
      });
      describe("with only a callback", function() {
        var commits, repo;
        repo = fixtures.branched;
        commits = null;
        before(function(done) {
          return repo.commits(function(err, _commits) {
            commits = _commits;
            return done(err);
          });
        });
        it("passes an Array", function() {
          return commits.should.be.an["instanceof"](Array);
        });
        return it("is a list of commits", function() {
          commits[0].id.should.eql("913318e66e9beed3e89e9c402c1d6585ef3f7e6f");
          commits[0].repo.should.eql(repo);
          commits[0].author.name.should.eql("sentientwaffle");
          commits[0].committer.name.should.eql("sentientwaffle");
          commits[0].authored_date.should.be.an["instanceof"](Date);
          commits[0].committed_date.should.be.an["instanceof"](Date);
          commits[0].parents().should.be.an["instanceof"](Array);
          return commits[0].message.should.eql("add a sub dir");
        });
      });
      describe("specify a branch", function() {
        var commits, repo;
        repo = fixtures.branched;
        commits = null;
        before(function(done) {
          return repo.commits("something", function(err, _commits) {
            commits = _commits;
            return done(err);
          });
        });
        it("is the latest commit", function() {
          return commits[0].message.should.eql("2");
        });
        return it("has a parent commit", function() {
          commits[0].parents().should.have.lengthOf(1);
          return commits[0].parents()[0].id.should.eql(commits[1].id);
        });
      });
      describe("specify a tag", function() {
        var commits, repo;
        repo = fixtures.tagged;
        commits = null;
        before(function(done) {
          return repo.commits("tag-1", function(err, _commits) {
            commits = _commits;
            return done(err);
          });
        });
        return it("is the latest commit on the tag", function() {
          return commits[0].message.should.containEql("commit 5");
        });
      });
      describe("limit the number of commits", function() {
        var commits, repo;
        repo = fixtures.tagged;
        commits = null;
        before(function(done) {
          return repo.commits("master", 2, function(err, _commits) {
            commits = _commits;
            return done(err);
          });
        });
        return it("returns 2 commits", function() {
          return commits.should.have.lengthOf(2);
        });
      });
      describe("skip commits", function() {
        var commits, repo;
        repo = fixtures.tagged;
        commits = null;
        before(function(done) {
          return repo.commits("master", 1, 2, function(err, _commits) {
            commits = _commits;
            return done(err);
          });
        });
        return it("returns 2 commits", function() {
          return commits[0].message.should.containEql("commit 4");
        });
      });
      return describe("with or without gpg signature", function() {
        var commits, repo;
        repo = fixtures.gpgsigned;
        commits = null;
        before(function(done) {
          return repo.commits("master", function(err, _commits) {
            commits = _commits;
            return done(err);
          });
        });
        it("has no gpgsig", function() {
          return commits[0].gpgsig.should.not.be.ok;
        });
        it("has gpgsig", function() {
          return commits[1].gpgsig.should.be.ok;
        });
        return it("contains the correct signature", function() {
          return commits[1].gpgsig.should.equal("-----BEGIN" + " " + "PGP" + " " + "SIGNATURE-----\n" + " " + "Version:" + " " + "GnuPG" + " " + "v2.0.22" + " " + "(GNU/Linux)\n" + " " + "\n" + " " + "iQEcBAABAgAGBQJTQw8qAAoJEL0/h9tqDFPiP3UH/RwxUS90+6DEkThcKMmV9H4K\n" + " " + "dr+D0H0z2ViMq3AHSmCydv5dWr3bupl2XyaLWWuRCxAJ78xuf98qVRIBfT/FKGeP\n" + " " + "fz+GtXkv3naCD12Ay6YiwfxSQhxFiJtRwP5rla2i7hlV3BLFPYCWTtL8OLF4CoRm\n" + " " + "7aF5EuDr1x7emEDyu1rf5E59ttSIySuIw0J1mTjrPCkC6lsowzTJS/vaCxZ3e7fN\n" + " " + "iZE6VEWWY/iOxd8foJH/VZ3cfNKjfi8+Fh8t7o9ztjYTQAOZUJTn2CHB7Wkyr0Ar\n" + " " + "HNM3v26gPFpb7UkHw0Cq2HWNV/Z7cbQc/BQ4HmrmuBPB6SWNOaBN751BbQKnPcA=\n" + " " + "=IusH\n" + " " + "-----END" + " " + "PGP" + " " + "SIGNATURE-----");
        });
      });
    });
    describe("#tree", function() {
      var repo;
      repo = fixtures.branched;
      describe("master", function() {
        it("is a Tree", function() {
          return repo.tree().should.be.an["instanceof"](Tree);
        });
        return it("checks out branch:master", function(done) {
          return repo.tree().blobs(function(err, blobs) {
            return blobs[0].data(function(err, data) {
              data.should.containEql("Bla");
              data.should.not.containEql("Bla2");
              return done(err);
            });
          });
        });
      });
      return describe("specific branch", function() {
        it("is a Tree", function() {
          return repo.tree("something").should.be.an["instanceof"](Tree);
        });
        return it("checks out branch:something", function(done) {
          return repo.tree("something").blobs(function(err, blobs) {
            return blobs[0].data(function(err, data) {
              data.should.containEql("Bla2");
              return done(err);
            });
          });
        });
      });
    });
    describe("#diff", function() {
      var repo;
      repo = fixtures.branched;
      return describe("between 2 branches", function() {
        var diffs;
        diffs = null;
        before(function(done) {
          return repo.diff("something", "master", function(err, _diffs) {
            diffs = _diffs;
            return done(err);
          });
        });
        it("is passes an Array of Diffs", function() {
          diffs.should.be.an["instanceof"](Array);
          return diffs[0].should.be.an["instanceof"](Diff);
        });
        it("modifies the README.md file", function() {
          diffs[0].a_path.should.eql("README.md");
          return diffs[0].b_path.should.eql("README.md");
        });
        return it("creates some/hi.txt", function() {
          diffs[1].new_file.should.be["true"];
          return diffs[1].b_path.should.eql("some/hi.txt");
        });
      });
    });
    describe("#remotes", function() {
      describe("in a repository with remotes", function() {
        var remotes, repo;
        repo = fixtures.remotes;
        remotes = null;
        before(function(done) {
          return repo.remotes(function(err, _remotes) {
            remotes = _remotes;
            return done(err);
          });
        });
        it("is an Array of Refs", function() {
          remotes.should.be.an["instanceof"](Array);
          return remotes[0].should.be.an["instanceof"](Ref);
        });
        return it("contains the correct Refs", function() {
          remotes[0].commit.id.should.eql("bdd3996d38d885e18e5c5960df1c2c06e34d673f");
          remotes[0].name.should.eql("origin/HEAD");
          remotes[1].commit.id.should.eql("bdd3996d38d885e18e5c5960df1c2c06e34d673f");
          return remotes[1].name.should.eql("origin/master");
        });
      });
      return describe("when there are no remotes", function() {
        var repo;
        repo = fixtures.branched;
        return it("is an empty Array", function() {
          return repo.remotes(function(err, remotes) {
            return remotes.should.eql([]);
          });
        });
      });
    });
    describe("#remote_list", function() {
      describe("in a repository with remotes", function() {
        var remotes, repo;
        repo = fixtures.remotes;
        remotes = null;
        before(function(done) {
          return repo.remote_list(function(err, _remotes) {
            remotes = _remotes;
            return done(err);
          });
        });
        return it("is a list of remotes", function() {
          remotes.should.have.lengthOf(1);
          return remotes[0].should.eql("origin");
        });
      });
      return describe("when there are no remotes", function() {
        var repo;
        repo = fixtures.branched;
        return it("is an empty Array", function() {
          return repo.remote_list(function(err, remotes) {
            return remotes.should.eql([]);
          });
        });
      });
    });
    describe("#tags", function() {
      describe("a repo with tags", function() {
        var repo, tags;
        repo = fixtures.tagged;
        tags = null;
        before(function(done) {
          return repo.tags(function(err, _tags) {
            tags = _tags;
            return done(err);
          });
        });
        it("is an Array of Tags", function() {
          tags.should.be.an["instanceof"](Array);
          return tags[0].should.be.an["instanceof"](Tag);
        });
        return it("is the correct tag", function() {
          return tags[0].name.should.eql("tag-1");
        });
      });
      return describe("a repo without tags", function() {
        var repo;
        repo = fixtures.branched;
        return it("is an empty array", function(done) {
          return repo.tags(function(err, tags) {
            tags.should.eql([]);
            return done(err);
          });
        });
      });
    });
    describe("#create_tag", function() {
      var git_dir, repo;
      repo = null;
      git_dir = __dirname + "/fixtures/junk_create_tag";
      before(function(done) {
        return fs.remove(git_dir, function(err) {
          if (err) {
            return done(err);
          }
          return fs.mkdir(git_dir, 0x1ed, function(err) {
            if (err) {
              return done(err);
            }
            return git.init(git_dir, function(err) {
              if (err) {
                return done(err);
              }
              repo = git(git_dir);
              return repo.identify(new Actor('name', 'em@il'), function() {
                fs.writeFileSync("" + git_dir + "/foo.txt", "cheese");
                return repo.add("" + git_dir + "/foo.txt", function(err) {
                  if (err) {
                    return done(err);
                  }
                  return repo.commit("initial commit", {
                    all: true
                  }, done);
                });
              });
            });
          });
        });
      });
      after(function(done) {
        return fs.remove(git_dir, done);
      });
      return it("creates a tag", function(done) {
        return repo.create_tag("foo", done);
      });
    });
    describe("#delete_tag", function() {
      return describe("deleting a tag that does not exist", function() {
        var repo;
        repo = fixtures.branched;
        return it("passes an error", function(done) {
          return repo.delete_tag("nonexistant-tag", function(err) {
            should.exist(err);
            return done();
          });
        });
      });
    });
    describe("#branches", function() {
      var branches, repo;
      repo = fixtures.branched;
      branches = null;
      before(function(done) {
        return repo.branches(function(err, _branches) {
          branches = _branches;
          return done(err);
        });
      });
      it("is an Array of Heads", function() {
        branches.should.be.an["instanceof"](Array);
        return branches[0].should.be.an["instanceof"](Head);
      });
      return it("has the correct branches", function() {
        branches[0].name.should.eql("master");
        return branches[1].name.should.eql("something");
      });
    });
    describe("#branch", function() {
      describe("when a branch name is given", function() {
        var branch, repo;
        repo = fixtures.branched;
        branch = null;
        before(function(done) {
          return repo.branch("something", function(err, b) {
            branch = b;
            return done(err);
          });
        });
        it("is a Head", function() {
          return branch.should.be.an["instanceof"](Head);
        });
        return it("has the correct name", function() {
          return branch.name.should.eql("something");
        });
      });
      describe("when no branch name is given", function() {
        var branch, repo;
        repo = fixtures.branched;
        branch = null;
        before(function(done) {
          return repo.branch(function(err, b) {
            branch = b;
            return done(err);
          });
        });
        return it("has the correct name", function() {
          return branch.name.should.eql("master");
        });
      });
      return describe("an invalid branch", function() {
        var repo;
        repo = fixtures.branched;
        return it("passes an error", function(done) {
          return repo.branch("nonexistant-branch", function(err, b) {
            should.exist(err);
            should.not.exist(b);
            return done();
          });
        });
      });
    });
    describe("#delete_branch", function() {
      return describe("a branch that does not exist", function() {
        var repo;
        repo = fixtures.branched;
        return it("passes an error", function(done) {
          return repo.delete_branch("nonexistant-branch", function(err) {
            should.exist(err);
            return done();
          });
        });
      });
    });
    describe("#reset", function() {
      var file, git_dir, repo, status;
      repo = null;
      git_dir = __dirname + "/fixtures/junk_reset";
      status = null;
      file = "bla.txt";
      beforeEach(function(done) {
        status = null;
        return fs.remove(git_dir, function(err) {
          if (err) {
            return done(err);
          }
          return fs.copy("" + __dirname + "/fixtures/reset", "" + git_dir, function(err) {
            if (err) {
              return done(err);
            }
            return fs.rename("" + git_dir + "/git.git", "" + git_dir + "/.git", function(err) {
              if (err) {
                return done(err);
              }
              return git.init(git_dir, function(err) {
                repo = git(git_dir);
                return fs.writeFile("" + git_dir + "/" + file, "hello", function(err) {
                  if (err != null) {
                    return done(err);
                  }
                  return repo.add("" + git_dir + "/" + file, function(err) {
                    return done(err);
                  });
                });
              });
            });
          });
        });
      });
      after(function(done) {
        return fs.remove(git_dir, function(err) {
          return done(err);
        });
      });
      describe("reset without specific treeish (defaults to HEAD)", function() {
        describe("reset (--mixed)", function() {
          beforeEach(function(done) {
            return repo.reset(function() {
              return repo.status(function(err, _status) {
                status = _status;
                return done(err);
              });
            });
          });
          return it("removes the file from index, leaves it in working tree", function() {
            status.files.should.have.a.property(file);
            status.files[file].staged.should.be["false"];
            status.files[file].tracked.should.be["false"];
            return status.files[file].should.not.have.a.property('type');
          });
        });
        describe("reset --soft", function() {
          beforeEach(function(done) {
            return repo.reset({
              soft: true
            }, function() {
              return repo.status(function(err, _status) {
                status = _status;
                return done(err);
              });
            });
          });
          return it("leaves the added file in the index", function() {
            status.files.should.have.a.property(file);
            status.files[file].staged.should.be["true"];
            status.files[file].tracked.should.be["true"];
            return status.files[file].type.should.eql('A');
          });
        });
        return describe("reset --hard", function() {
          beforeEach(function(done) {
            return repo.reset({
              hard: true
            }, function() {
              return repo.status(function(err, _status) {
                status = _status;
                return done(err);
              });
            });
          });
          return it("removes the file from index and working tree", function() {
            return status.files.should.not.have.a.property(file);
          });
        });
      });
      return describe("reset to specific treeish", function() {
        describe("reset (--mixed) HEAD~1", function() {
          beforeEach(function(done) {
            return repo.reset('HEAD~1', function() {
              return repo.status(function(err, _status) {
                status = _status;
                return done(err);
              });
            });
          });
          return it("resets to HEAD~1, changes stay in the working tree", function() {
            status.files.should.have.a.property(file);
            status.files[file].staged.should.be["false"];
            status.files[file].tracked.should.be["false"];
            status.files[file].should.not.have.a.property('type');
            status.files.should.have.a.property('rawr.txt');
            status.files['rawr.txt'].staged.should.be["false"];
            status.files['rawr.txt'].tracked.should.be["false"];
            return status.files['rawr.txt'].should.not.have.a.property('type');
          });
        });
        describe("reset --soft HEAD~1", function() {
          beforeEach(function(done) {
            return repo.reset('HEAD~1', {
              soft: true
            }, function() {
              return repo.status(function(err, _status) {
                status = _status;
                return done(err);
              });
            });
          });
          return it("resets to HEAD~1, changes stay in the index and working tree", function() {
            status.files.should.have.a.property(file);
            status.files[file].staged.should.be["true"];
            status.files[file].tracked.should.be["true"];
            status.files[file].type.should.eql('A');
            status.files.should.have.a.property('rawr.txt');
            status.files['rawr.txt'].staged.should.be["true"];
            status.files['rawr.txt'].tracked.should.be["true"];
            return status.files['rawr.txt'].type.should.eql('AM');
          });
        });
        return describe("reset --hard HEAD~1", function() {
          beforeEach(function(done) {
            return repo.reset('HEAD~1', {
              hard: true
            }, function() {
              return repo.status(function(err, _status) {
                status = _status;
                return done(err);
              });
            });
          });
          return it("resets to HEAD~1, all changes get discarded completely", function() {
            status.files.should.not.have.a.property(file);
            return status.files.should.not.have.a.property('rawr.txt');
          });
        });
      });
    });
    return describe("#checkoutFile", function() {
      var file, git_dir, repo, status;
      repo = null;
      git_dir = __dirname + "/fixtures/junk_checkoutFile";
      status = null;
      file = "bla.txt";
      beforeEach(function(done) {
        status = null;
        return fs.remove(git_dir, function(err) {
          if (err) {
            return done(err);
          }
          return fs.copy("" + __dirname + "/fixtures/reset", "" + git_dir, function(err) {
            if (err) {
              return done(err);
            }
            return fs.rename("" + git_dir + "/git.git", "" + git_dir + "/.git", function(err) {
              return git.init(git_dir, function(err) {
                if (err) {
                  return done(err);
                }
                repo = git(git_dir);
                return fs.writeFile("" + git_dir + "/" + file, "hello", function(err) {
                  if (err != null) {
                    return done(err);
                  }
                  return repo.add("" + git_dir + "/" + file, function(err) {
                    return done(err);
                  });
                });
              });
            });
          });
        });
      });
      after(function(done) {
        return fs.remove(git_dir, function(err) {
          return done(err);
        });
      });
      describe("passing no explicit files", function() {
        beforeEach(function(done) {
          return repo.checkoutFile(function() {
            return repo.status(function(err, _status) {
              status = _status;
              return done(err);
            });
          });
        });
        return it("discards changes in the working tree for all files", function() {
          status.files.should.have.a.property(file);
          status.files[file].staged.should.be["true"];
          status.files[file].tracked.should.be["true"];
          status.files[file].type.should.eql('A');
          status.files.should.have.a.property('rawr.txt');
          status.files['rawr.txt'].staged.should.be["true"];
          status.files['rawr.txt'].tracked.should.be["true"];
          return status.files['rawr.txt'].type.should.eql('M');
        });
      });
      return describe("passing an explicit file", function() {
        beforeEach(function(done) {
          return repo.checkoutFile('rawr.txt', function() {
            return repo.status(function(err, _status) {
              status = _status;
              return done(err);
            });
          });
        });
        return it("discard changes to the specified file", function() {
          status.files.should.have.a.property('rawr.txt');
          status.files['rawr.txt'].staged.should.be["true"];
          status.files['rawr.txt'].tracked.should.be["true"];
          return status.files['rawr.txt'].type.should.eql('M');
        });
      });
    });
  });

}).call(this);
